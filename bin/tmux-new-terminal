#!/usr/bin/env bash

################################################################################
# This file is part of the tmuxrc package. It is subject to the
# license terms in the LICENSE file found in the top-level directory
# of this distribution and at git://git.devalot.com/tmuxrc/LICENSE. No
# part of this package, including this file, may be copied, modified,
# propagated, or distributed except according to the terms contained
# in the LICENSE file.

################################################################################
# This script is an overly complex way of hiding tmux in a terminal
# emulator.  Each new terminal that is opened has a unique tmux
# session associated with it.  However, all terminals from the same
# desktop are grouped together using a session name prefix.
#
# Closing the only tmux window or the terminal will terminate the
# current session.  Turning on the tmux status bar will tell this
# script that you want the session to persist.

################################################################################
SESSION_GROUP=""
SESSION_NAME=""
TTY_NUMBER=$(tty | cut -d/ -f4)
TERM_CLOSED=0

################################################################################
# Some environment variables for the new session:
GPG_TTY=$(tty)
export GPG_TTY

################################################################################
usage() {
  cat <<EOF
Usage: tmux-new-terminal [options]

  -h      This message
  -g NAME Set the session group name
  -s NAME Set the target session name
EOF
}

################################################################################
while getopts "hg:s:" o; do
  case "${o}" in
  h)
    usage
    exit
    ;;

  g)
    SESSION_GROUP=$OPTARG
    ;;

  s)
    SESSION_NAME=$OPTARG
    ;;

  *)
    exit 1
    ;;
  esac
done

shift $((OPTIND - 1))

################################################################################
# Find a session in the current group that has no clients.
find_inactive_sessions() {
  local format='#{session_name}|#{session_attached}'

  (tmux list-sessions -F "$format" || :) |
    (grep --fixed-strings "/${SESSION_GROUP}|0" || :) |
    cut -d'|' -f1
}

################################################################################
# When the parent terminal closes, figure out what to do with tmux.
terminal_window_closed() {
  if [ "$TERM_CLOSED" -eq 1 ]; then return; fi
  TERM_CLOSED=1

  trap "" SIGHUP  # Don't re-enter this function
  trap "" SIGPIPE # Don't die on writes to the terminal

  status=$(tmux show-options -t "$SESSION_NAME" -v status)
  windows=$(tmux list-windows -t "$SESSION_NAME" | wc -l)

  if [ "$status" = "on" ] || [ "$windows" -gt 1 ]; then
    # Help tmux know the session is detached.  Without this it will
    # still display the session as attached.
    tmux detach-client -s "$SESSION_NAME"
  else
    # Kill the session and its windows.
    tmux kill-session -t "$SESSION_NAME"
  fi
}

################################################################################
# Create a new session and group it with $SESSION_GROUP.
join_session() {
  local other_session
  other_session=$(find_inactive_sessions | sort | head -1)

  # Deal with the outer terminal window closing.
  trap terminal_window_closed SIGHUP

  # Start tmux.
  if [ -n "$other_session" ]; then
    tmux attach-session -t "$other_session"
  else
    tmux new-session -A -s "$SESSION_NAME"
  fi
}

################################################################################
# Take the session group from the current workspace name.
if [ -z "$SESSION_GROUP" ] && [ -n "$DISPLAY" ]; then
  SESSION_GROUP=$( (wmctrl -d || echo "* 0") | awk '($2 ~ /\*/) {print $NF}')
fi

# Failing that, set it to something generic.
[ -z "$SESSION_GROUP" ] && SESSION_GROUP=scratch

# Take the session name from the group and current TTY.
# (The $TTY_NUMBER is used to ensure the session name is unique.)
if [ -z "$SESSION_NAME" ]; then
  SESSION_NAME="$SESSION_GROUP/$TTY_NUMBER"
fi

join_session
